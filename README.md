# Compiler in Python: Design Document

Group Members: Charles Hermann, Izeah Olguin, Paco Coursey

Last Updated: 02/7/2019

## Quickstart

Clone the repository:

```bash
$ git clone https://github.com/pacocoursey/compiler.git
```

## Overview

Our Python compiler currently meets the standards expected of the first
deliverable. Our scanner reads in a file as a string of characters and produces a list of labeled tokens. These tokens become acquired by the parser and produce an abstract representation.

As a group, we have met numerous times to discuss our design, implementation and overall expectations of our compiler.

As mentioned during the code review in class, our Python code is a bit extensive, however this contributes to the readability and allows our software to be more dynamic.

## Usage

Our compiler uses Python 3.

### Character Count

This program returns the number of characters found in a given file. Run using:

```bash
$ python3 src/character_count.py FILENAME
```

### Scanner

The scanner tokenizes a C program and returns a list of the known tokens. Run using:

```bash
$ python3 src/main.py -s samples/plain.c
```

### Parser

The parser converts a list of tokens generated by the scanner and constructs an abstract representation of the program using a pre-defined C grammar. Run using:

```bash
$ make main
# or
$ python3 src/main.py -s -p samples/plain.c
```

## Design Discussion

### Scanner Implementation

Our scanner parses characters in a 'chunk', with a start an and end counter. We iterate through the chunk to match our tokens in the following order: Symbols, Operators, Keywords, Identifiers and Numbers.

We are not focused on speed, which is why we opted not to use regular expressions. This gives us more logical control over what tokens we recognize, and it is easier to handle edge cases like multi-line comments.

### Parser Implementation

Currently, we have implemented seven classes, which are within their own file titled `classes.py`. These classes are then defined within `grammar.py`. 'grammar.py', which also contains our list of rules, which we currently recognize. In the near future (by the next deliverable), we will utilize the parse method
and only have one file, rather than separating the 'classes.py' file from the 'grammar.py' file.

The `paser.py` file design is similar to that of Nora Sandler's design. We employ a recursive descent parsing algorithm, which pushes elements onto a stack from right to left. Finally, we then shift, reduce and repeat.

In the rules of `grammar.py`, we attempt to break as early as possible to avoid checking more tokens than we have to. This helps speed up the rule searching.

### Limitations

- Large code base
- Rule searching rather than action/goto tables
- Small subset of grammar implemented
- Complex logic on rule specification

### Benefits

- Few files, things can be modified quickly
- Design and hierarchy is well established
- Good separation of concepts into modularized files

## Scanner Specification

Tokens that we currently recognize:

- [X] Identifiers
- [X] Numbers (ints)
- [X] Block symbols `(, ), {, }, [, ]`
- [X] Unary operators `&, |, ^, ~`
- [X] Equality operators `<, >, <=, >=, ==, !=`
- [X] Assignment operators `=, +=, -=, *=, /=, ++, --`
- [X] Strings `"", ''`
- [X] Misc tokens `,, ., ;, \\, ->, #`
- [X] Sum operators `+, -`
- [X] Multiplication operators `*, /, %`
- [X] Boolean operators `&&, ||, !, <<, >>`
- [X] Number type keywords `int, long, double, short, signed, unsigned, float`
- [X] Data type keywords `struct, enum, union, record`
- [X] Flow control keywords `if, else, while, for, break, continue, return`
- [X] Boolean keywords `true, false`
- [X] Misc keywords `static, sizeof, typedef, const, extern, auto`

Tokens that we should recognize in the future:

- [ ] Numbers (floats)


## Grammar Specification

High level AST nodes that we currently recognize:

- [X] Program
- [X] Function Declaration
- [X] Type Specifier: int
- [X] Return Statement
- [X] Number Constant: int
- [X] Identifiers

AST nodes that we will recognize in the next few weeks:

- [ ] Variable Declaration
- [ ] Type Specifier: bool, char, float
- [ ] More Statement types

## Class-defined Specifications

Features required in our implementation.

- [ ] Functions
- [ ] Return
- [ ] Break
- [ ] Variables
- [ ] Arithmetic (+, -, *,)
- [ ] Assignment
- [ ] Boolean Expressions
- [ ] Goto
- [ ] If
- [ ] While
- [ ] Unary Operators
- [ ] Integers (default, signed, syslen)

### Extra Features

Extra features for bonus points.

- [ ] `char`, `float`
- [ ] For
- [ ] Switch
- [ ] Binary Operators (&, |, ^)
- [ ] Assignment Helpers (+=, -=, *=, /=, ++, --)

### Out of Bound Features

Extremely extra features.

- Pointers
- Arrays
- Compiler Preprocessing (macros, #include)
- Struct
- Enum
- Library Calls
- Casting
- Promotion
- Strings
- Type Specs

### Proposed Grammar

- program ::= statement; | program statement;
- statement ::= assign | if | while | print | function
---
- assign ::= intVariable = numericalExpression | boolVariable = boolExpression
- if ::= if boolExpression then program endif | if boolExpression then program else program endif
- while ::= while boolExpression do program endwhile
- print ::= print int | print bool | print char | print string | print intVariable | print boolVariable |
- function ::=
---
- intVariable ::= char string
- boolVariable ::= char string
---
- numericalExpression ::= int | intVariable | s
- s ::= t | s+t | s-t
- t ::= e | txe | t/e
- e ::= p | p^e
- p ::= int | (s)
---
- boolExpression ::= m | boolExpression & m | boolExpression || m
- m ::= o | !m
- o ::= grb | (boolExpression)
- grb ::= bool | boolVariable | numericalExpression == numericalExpression | numericalExpression > numericalExpression | numericalExpression < numericalExpression
---
- string ::= char | int | string char | string int
- char ::= [a - z][A - Z]
- int ::= [0 - 9] | [0 - 9] int
- bool ::= True | False

## Code Style

Using [Black](https://github.com/ambv/black).

## Related

- [SmallerC](https://github.com/alexfru/smallerc)
- [Tiny C Compiler](https://bellard.org/tcc/)
